<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PGP - Pure Graphics Programming: shaderutils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PGP - Pure Graphics Programming
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A Simple Graphics Programming Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">shaderutils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshaderutils_1_1_shader_proxy.html">ShaderProxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65da9931b0094fc28feb81c3e561f0f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshaderutils.html#a65da9931b0094fc28feb81c3e561f0f0">getErrorShaderInfoLog</a> (GLuint target, GLuint type)</td></tr>
<tr class="separator:a65da9931b0094fc28feb81c3e561f0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30962b257d22ef93daf84638ab350c54"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshaderutils.html#a30962b257d22ef93daf84638ab350c54">genProgram</a> (const char *vsname, const char *fsname)</td></tr>
<tr class="separator:a30962b257d22ef93daf84638ab350c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd5a3672853d5682b4ed455ec14a8a8"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshaderutils.html#a3dd5a3672853d5682b4ed455ec14a8a8">createVertexBuffer</a> ()</td></tr>
<tr class="separator:a3dd5a3672853d5682b4ed455ec14a8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952f4510fcf359caa18418388d5a3a6b"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshaderutils.html#a952f4510fcf359caa18418388d5a3a6b">createElementBuffer</a> ()</td></tr>
<tr class="separator:a952f4510fcf359caa18418388d5a3a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80123a5faeea08f96535d0072c9fae6"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshaderutils.html#aa80123a5faeea08f96535d0072c9fae6">createTexture</a> ()</td></tr>
<tr class="separator:aa80123a5faeea08f96535d0072c9fae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567a32c32ffab34ac65b9772152fde7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshaderutils.html#a567a32c32ffab34ac65b9772152fde7a">setTextureImage</a> (GLuint texID, const GLvoid *data, GLsizei width, GLsizei height, GLenum target=GL_TEXTURE_2D, GLint level=0, GLint internalFormat=GL_RGBA, GLint border=0, GLenum format=GL_RGBA, GLenum type=GL_UNSIGNED_BYTE)</td></tr>
<tr class="separator:a567a32c32ffab34ac65b9772152fde7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb43fbeaf982bca26005030f22b80308"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshaderutils.html#abb43fbeaf982bca26005030f22b80308">setVertexDataBuffer</a> (GLuint bufferID, GLfloat *values, GLuint countBytes, GLenum mode=GL_STATIC_DRAW)</td></tr>
<tr class="separator:abb43fbeaf982bca26005030f22b80308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f248cb6d3c97c800044f60903334e0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceshaderutils.html#a3f248cb6d3c97c800044f60903334e0e">setElementDataBuffer</a> (GLuint bufferID, GLuint *values, GLuint countBytes, GLenum mode=GL_STATIC_DRAW)</td></tr>
<tr class="separator:a3f248cb6d3c97c800044f60903334e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Espaço de nome shaderutils: este espaço de nome contém todas as funções e classes que facilitam a troca de dados entre programa cliente e os shaders que rodam no hardware gráfico. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a952f4510fcf359caa18418388d5a3a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952f4510fcf359caa18418388d5a3a6b">&#9670;&nbsp;</a></span>createElementBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint shaderutils::createElementBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cria um ELEMENT_ARRAY_BUFFER. </p><dl class="section return"><dt>Returns</dt><dd>GLuint o identificador do buffer gerado. </dd></dl>

</div>
</div>
<a id="aa80123a5faeea08f96535d0072c9fae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80123a5faeea08f96535d0072c9fae6">&#9670;&nbsp;</a></span>createTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint shaderutils::createTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cria uma textura. </p><dl class="section return"><dt>Returns</dt><dd>o identificador da textura criada. </dd></dl>

</div>
</div>
<a id="a3dd5a3672853d5682b4ed455ec14a8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd5a3672853d5682b4ed455ec14a8a8">&#9670;&nbsp;</a></span>createVertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint shaderutils::createVertexBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cria um GL_VERTEX_BUFFER. </p><dl class="section return"><dt>Returns</dt><dd>GLuint o identificador do buffer gerado. </dd></dl>

</div>
</div>
<a id="a30962b257d22ef93daf84638ab350c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30962b257d22ef93daf84638ab350c54">&#9670;&nbsp;</a></span>genProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint shaderutils::genProgram </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vsname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fsname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compila os dois shaders apontados pelos arquivos vsname e fsname. A funcao compila os shaders e retorna o identificador do programa correspondente ou lanca uma exceccao cujo argumento eh uma string indicando o erro que ocorreu. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsname</td><td>é o path do vertex shader a ser compilado e ligado. </td></tr>
    <tr><td class="paramname">fsname</td><td>é o path do fragment shader a ser compilado e ligado. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GLuint o identificador do programa gerado. </dd></dl>

</div>
</div>
<a id="a65da9931b0094fc28feb81c3e561f0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65da9931b0094fc28feb81c3e561f0f0">&#9670;&nbsp;</a></span>getErrorShaderInfoLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void shaderutils::getErrorShaderInfoLog </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Esta função lança uma exceção contendo informações do erro ocorrido, caso algum erro de compilação ou ligação de shader tenha ocorrido. Caso, nenhum erro de compilação ou de ligação de shader tenha ocorrido, a função não faz nada.  GLuint target programa que está sendo compilado ou ligado.  type tipo de shader (GL_VERTEX_SHADER ou GL_FRAGMENT_SHADER). </p>

</div>
</div>
<a id="a3f248cb6d3c97c800044f60903334e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f248cb6d3c97c800044f60903334e0e">&#9670;&nbsp;</a></span>setElementDataBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void shaderutils::setElementDataBuffer </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>bufferID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>countBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>mode</em> = <code>GL_STATIC_DRAW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Permite fornecer os dados a serem armazenados em um element buffer com identificador passado como argumento no parâmetro <code>bufferID</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferID</td><td>o identificador do element buffer onde os dados devem ser armazenados. </td></tr>
    <tr><td class="paramname">values</td><td>um ponteiro para os dados a serem armazenados. </td></tr>
    <tr><td class="paramname">countBytes</td><td>a quantidade de bytes a serem armazenados no buffer. </td></tr>
    <tr><td class="paramname">mode</td><td>especifíca o padrão de uso dos dados a serem armazenados. As constantes simbólicas devem ser GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, ou GL_DYNAMIC_COPY. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a567a32c32ffab34ac65b9772152fde7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567a32c32ffab34ac65b9772152fde7a">&#9670;&nbsp;</a></span>setTextureImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void shaderutils::setTextureImage </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>texID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLvoid *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>target</em> = <code>GL_TEXTURE_2D</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>internalFormat</em> = <code>GL_RGBA</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>border</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>format</em> = <code>GL_RGBA</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>type</em> = <code>GL_UNSIGNED_BYTE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associa uma imagem à textura cujo identificador é <code>texID</code>. Os dados da imagem são indicados pelo parâmetro <code>data</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texID</td><td>identificador da textura </td></tr>
    <tr><td class="paramname">data</td><td>especifíca um ponteiro para os dados da imagem na memória. </td></tr>
    <tr><td class="paramname">width</td><td>largura da imagem em pixels </td></tr>
    <tr><td class="paramname">height</td><td>altura da imagem em pixels </td></tr>
    <tr><td class="paramname">target</td><td>o objetivo das texturas. Valores possíveis são: GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z ou GL_PROXY_TEXTURE_CUBE_MAP. </td></tr>
    <tr><td class="paramname">level</td><td>especifíca o nível de detalhe. Nível 0 é a imagem base. Nível n é a n-ésima redução de mipmap. Se <code>target</code> é GL_TEXTURE_RECTANGLE ou GL_PROXY_TEXTURE_RECTANGLE, o nível deve ser 0. </td></tr>
    <tr><td class="paramname">internalFormat</td><td>especifíca a quantidade de componentes de cor na textura. Consulte documentação completa da função glTexImage2D para saber mais. </td></tr>
    <tr><td class="paramname">border</td><td>Este valor deve ser 0 (zero). </td></tr>
    <tr><td class="paramname">format</td><td>especifíca o formato dos dados dos pixels. Os seguintes valores simbólicos são aceitos: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL. </td></tr>
    <tr><td class="paramname">type</td><td>Especifíca o tipo de dados dos dados dos pixels. Os seguintes valores são aceitos: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, e GL_UNSIGNED_INT_2_10_10_10_REV. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb43fbeaf982bca26005030f22b80308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb43fbeaf982bca26005030f22b80308">&#9670;&nbsp;</a></span>setVertexDataBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void shaderutils::setVertexDataBuffer </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>bufferID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>countBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>mode</em> = <code>GL_STATIC_DRAW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Permite fornecer os dados a serem armazenados em um vertex buffer com identificador passado como argumento no parâmetro <code>bufferID</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferID</td><td>o identificador do vertex buffer onde os dados devem ser armazenados. </td></tr>
    <tr><td class="paramname">values</td><td>um ponteiro para os dados a serem armazenados. </td></tr>
    <tr><td class="paramname">countBytes</td><td>a quantidade de bytes a serem armazenados no buffer. </td></tr>
    <tr><td class="paramname">mode</td><td>especifíca o padrão de uso dos dados a serem armazenados. As constantes simbólicas devem ser GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, ou GL_DYNAMIC_COPY. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
